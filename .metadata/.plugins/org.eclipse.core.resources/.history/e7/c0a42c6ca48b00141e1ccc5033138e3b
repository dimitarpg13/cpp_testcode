//============================================================================
// Name        : replaceTypeExcercise.cpp
// Author      : Dimitar Gueorguiev
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <type_traits>
#include <typeinfo>

using namespace std;

template <typename C, typename X, typename Y>
struct replace_type
{
   typedef C type;
};

template <typename C, typename X, typename Y>
struct replace_type<C &, X, Y>
{
   typedef Y & type;
};

template <bool _isFunc, typename C, typename X, typename Y>
struct __replace_type_impl
{
   typedef C type;
};

template <typename C, typename X, typename Y>
struct __replace_type_impl<true, C, X, Y>
{
   typedef C type;
};

template <typename F, typename Arg>
struct make_func
{
 //  typedef F type;
};

template <typename F, typename X, typename Y>
struct __replace_type_func
{
  typedef F type;
};

template <typename F, typename X, typename Y>
struct __replace_type_func<F(X),X,Y>
{
  //typedef typename (make_func<X,F>::type) type;
  typedef Y type;
};



class X {};
enum Y {};
struct Z {};
typedef int A;
int myfunc(int);

int main() {
	cout << "Template Metaprogramming Exercise 2.1 : replace_type" << endl; // prints Template Metaprogramming Exercise 2.0 : add_const_reference
//remove_reference<int&>::
	cout << boolalpha << endl;
	cout << "typedef int A is compount type: " << is_compound<A>::value << endl;
	cout << "myfunc is a function: " << is_function<decltype(myfunc)>::value << endl;
	typedef __replace_type_func<decltype(myfunc),float, int>::type mt1;
	cout << "replace_type_func: " << typeid(mt1).name() << endl;
    mt1& mtval1 = myfunc; //= -1.1f;
    //cout << "mtval1 = " << mtval1 << endl;
	return 0;
}
