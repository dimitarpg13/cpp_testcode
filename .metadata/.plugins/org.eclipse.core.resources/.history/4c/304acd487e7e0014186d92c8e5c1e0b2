//============================================================================
// Name        : BoostCityVisitor.cpp
// Author      : Dimitar Gueorguiev
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <vector>
#include <string>

#include <boost/config.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/depth_first_search.hpp>
#include <boost/graph/breadth_first_search.hpp>
#include <boost/property_map/property_map.hpp>
#include <boost/graph/graph_utility.hpp> // for boost::make_list

/*
 * Example of using a visitor with breadth_first_search and deapth_first_search algorithms
 *
 * Sacramento ---- Reno ---- Salt Lake City
 * 		|
 * San Fransisco
 * 		|
 * San Jose ---- Fresno
 * 		|
 * Los Angeles  ----  Las Vegas ---- Phoenix
 * 		|
 * San Diego
 *
 * The visitor has three main functions:
 *
 * discover_vertex(u,g) is invoked when the algorithm first arrives at vertex u.
 * 	This will happen on the depth first or breadth first order depending on which
 * 	algorithm is used.
 *
 * examine_edge(e,g) is invoked when the algorithm first checks an edge to see
 * 	whether it has been already there. Whether using BFS or DFS, all the edges of
 * 	vertex u are examined immediately after the call to visit(u).
 *
 * finish_vertex(u, g) is called after all vertices reachable from u have been visited
 */


using namespace std;
using namespace boost;

struct city_arrival : public base_visitor<city_arrival>
{
   city_arrival(string * n) : names(n) {}
   typedef on_discover_vertex event_filter;
   template <class Vertex, class Graph>
   	   inline void operator() (Vertex u, Graph& g) {
	      cout << endl << "arriving at " << names[u] << endl
	    		  << " neighboring cities are: ";
       }
   string* names;
};

int main() {



	return 0;
}
