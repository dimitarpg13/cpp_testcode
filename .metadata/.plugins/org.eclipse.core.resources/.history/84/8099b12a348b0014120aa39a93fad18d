//============================================================================
// Name        : replaceTypeExcercise.cpp
// Author      : Dimitar Gueorguiev
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <type_traits>

using namespace std;

template <typename C, typename X, typename Y>
struct replace_type
{
   typedef C type;
};

template <typename C, typename X, typename Y>
struct replace_type<C &, X, Y>
{
   typedef Y & type;
};

template <bool _isFunc, typename C, typename X, typename Y>
struct __replace_type_impl
{
   typedef C type;
};

template <typename C, typename X, typename Y>
struct __replace_type_impl<true, C, X, Y>
{
   typedef C type;
};

template <typename F, typename Arg>
struct make_func
{
   static typename decltype(F) type;
};

template <typename F, typename X, typename Y>
struct __replace_type_func
{
  typedef F type;
};

template <typename F, typename X, typename Y>
struct __replace_type_func<X(F),X,Y>
{
  typedef make_func<X,F>::type type;
};



class X {};
enum Y {};
struct Z {};
typedef int A;
int myfunc(int);

int main() {
	cout << "Template Metaprogramming Exercise 2.1 : replace_type" << endl; // prints Template Metaprogramming Exercise 2.0 : add_const_reference
//remove_reference<int&>::
	cout << boolalpha << endl;
	cout << "typedef int A is compount type: " << is_compound<A>::value << endl;
	cout << "myfunc is a function: " << is_function<decltype(myfunc)>::value << endl;
	return 0;
}
